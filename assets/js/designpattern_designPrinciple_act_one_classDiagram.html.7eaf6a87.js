"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[5639],{6262:(i,s)=>{s.A=(i,s)=>{const e=i.__vccOpts||i;for(const[i,a]of s)e[i]=a;return e}},607:(i,s,e)=>{e.r(s),e.d(s,{comp:()=>l,data:()=>p});var a=e(641);const n=[(0,a.Fv)('<h1 id="_1、类图总览" tabindex="-1"><a class="header-anchor" href="#_1、类图总览"><span>1、类图总览</span></a></h1><h2 id="一、创建型" tabindex="-1"><a class="header-anchor" href="#一、创建型"><span>一、创建型</span></a></h2><h3 id="_1-simple-factory-method-简单工厂方法" tabindex="-1"><a class="header-anchor" href="#_1-simple-factory-method-简单工厂方法"><span>1. Simple Factory Method（简单工厂方法）</span></a></h3><p>定义：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。</p><p>类图：</p><figure><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/202406111953482.png" alt="image-20240611195324067" tabindex="0" loading="lazy"><figcaption>image-20240611195324067</figcaption></figure><p>案例说明：<br><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/202406201837277.png" alt="" loading="lazy"></p><h3 id="_2、factory-method-工厂方法" tabindex="-1"><a class="header-anchor" href="#_2、factory-method-工厂方法"><span>2、Factory Method（工厂方法）</span></a></h3><figure><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/202406201838833.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_3-abstract-factory-抽象工厂" tabindex="-1"><a class="header-anchor" href="#_3-abstract-factory-抽象工厂"><span>3. Abstract Factory（抽象工厂）</span></a></h3><p><em>定义：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</em></p><p><em>类图：</em></p><figure><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/抽象工厂模式.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="_3-builder-生成器模式" tabindex="-1"><a class="header-anchor" href="#_3-builder-生成器模式"><span>3. Builder（生成器模式）</span></a></h3><p><em>定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</em></p><p><em>类图：</em></p><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/生成器模式.png" alt="img" style="zoom:150%;"><p>实例：<br><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/202406211001742.png" alt="" loading="lazy"></p><h3 id="_4-prototype-原型模式" tabindex="-1"><a class="header-anchor" href="#_4-prototype-原型模式"><span>4. Prototype（原型模式）</span></a></h3><p><em>定义：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</em></p><p><em>类图：</em></p><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/原型模式.png" alt="img" style="zoom:150%;"><p>案例：<br><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/202406211009260.png" alt="" loading="lazy"></p><h3 id="_5-singleton-单件模式" tabindex="-1"><a class="header-anchor" href="#_5-singleton-单件模式"><span>5. Singleton（单件模式）</span></a></h3><p><em>定义：确保一个类只有一个实例，并提供全局访问点。</em></p><p><em>类图：</em></p><figure><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/单例模式.png" alt="image-20240611195845945" tabindex="0" loading="lazy"><figcaption>image-20240611195845945</figcaption></figure><p><em>代码：</em></p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Singleton</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> volatile</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Singleton</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> uniqueInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> object singletonData </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Singleton</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    { }</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Singleton</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> GetInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (uniqueInstance </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        {</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">            lock</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (singletonData)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">            {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">                if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (uniqueInstance </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">                {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">                    uniqueInstance </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Singleton</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">                }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">            }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        }</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> uniqueInstance;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>案例：<br><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/202406211011262.png" alt="" loading="lazy"></p><h2 id="二、结构性" tabindex="-1"><a class="header-anchor" href="#二、结构性"><span>二、结构性</span></a></h2><h3 id="_1-adapter-适配器模式-类、对象" tabindex="-1"><a class="header-anchor" href="#_1-adapter-适配器模式-类、对象"><span>1. Adapter（适配器模式（类、对象））</span></a></h3><p><em>定义：将一个类的接口转换成客户期望的另一个接口，适配器让原本接口不兼容的类可以合作无间。</em></p><p><em>类图：</em></p><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/适配器.png" alt="img" style="zoom:150%;"><p>案例：<br><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/202406211014964.png" alt="" loading="lazy"></p><h3 id="_2-bridge-桥连模式" tabindex="-1"><a class="header-anchor" href="#_2-bridge-桥连模式"><span>2. Bridge（桥连模式）</span></a></h3><p>定义：将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p><p><em>类图：</em></p><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/桥接.png" alt="img" style="zoom:150%;"><p>案例：<br><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/202406211016194.png" alt="" loading="lazy"></p><h3 id="_3-composite-组合模式" tabindex="-1"><a class="header-anchor" href="#_3-composite-组合模式"><span>3. Composite（组合模式）</span></a></h3><p>定义：将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。</p><p><em>类图：</em></p><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/组合模式.png" alt="img" style="zoom:150%;"><p>案例：<br><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/202406211018285.png" alt="" loading="lazy"></p><h3 id="_4-decorator-装饰模式" tabindex="-1"><a class="header-anchor" href="#_4-decorator-装饰模式"><span>4. Decorator（装饰模式）</span></a></h3><p>定义：动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更加灵活。</p><p><em>类图：</em></p><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/装饰器.png" alt="img" style="zoom:150%;"><p>案例<br><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/202406211016983.png" alt="" loading="lazy"></p><h3 id="_5-facade-外观模式" tabindex="-1"><a class="header-anchor" href="#_5-facade-外观模式"><span>5. Facade（外观模式）</span></a></h3><p><em>定义：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高级接口，这个接口使得这一子系统更加容易使用。</em></p><p><em>类图：</em></p><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/外观.png" alt="img" style="zoom:150%;"><p>案例：<br><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/202406211017371.png" alt="" loading="lazy"></p><h3 id="_6-flyweight-享元模式" tabindex="-1"><a class="header-anchor" href="#_6-flyweight-享元模式"><span>6. Flyweight（享元模式）</span></a></h3><p>定义：运用共享技术有效地支持大量细粒度的对象。</p><p><em>类图：</em></p><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/享元模式.png" alt="img" style="zoom:150%;"><p>案例：<br><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/202406211019356.png" alt="" loading="lazy"></p><h3 id="_7-proxy-代理模式" tabindex="-1"><a class="header-anchor" href="#_7-proxy-代理模式"><span>7. Proxy（代理模式）</span></a></h3><p>定义：为其他对象提供一种代理以控制对这个对象的访问。</p><p><em>类图：</em></p><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/代理模式.png" alt="img" style="zoom:150%;"><p>案例：<br><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/202406211012682.png" alt="" loading="lazy"></p><h2 id="三、行为型" tabindex="-1"><a class="header-anchor" href="#三、行为型"><span>三、行为型</span></a></h2><h3 id="_1-interpreter-解释器模式" tabindex="-1"><a class="header-anchor" href="#_1-interpreter-解释器模式"><span>1. Interpreter（解释器模式）</span></a></h3><p>定义：给定一个语言，定义它的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p><p><em>类图：</em></p><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/解释器模式.png" alt="img" style="zoom:150%;"><h3 id="_2-template-method-模板方法" tabindex="-1"><a class="header-anchor" href="#_2-template-method-模板方法"><span>2. Template Method（模板方法）</span></a></h3><p><em>定义：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</em></p><p><em>类图：</em></p><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/模板模式.png" alt="img" style="zoom:150%;"><h3 id="_3-chain-of-responsibility-职责链模式" tabindex="-1"><a class="header-anchor" href="#_3-chain-of-responsibility-职责链模式"><span>3. Chain of Responsibility（职责链模式）</span></a></h3><p>*定义：*<em>使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</em></p><p><em>类图：</em></p><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/职责链模式.png" alt="img" style="zoom:150%;"><h3 id="_4-command-命令模式" tabindex="-1"><a class="header-anchor" href="#_4-command-命令模式"><span>4. Command（命令模式）</span></a></h3><p>定义：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</p><p><em>类图：</em></p><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/命令模式.png" alt="img" style="zoom:150%;"><h3 id="_5-iterator-迭代模式" tabindex="-1"><a class="header-anchor" href="#_5-iterator-迭代模式"><span>5. Iterator（迭代模式）</span></a></h3><p>定义：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。</p><p><em>类图：</em></p><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/迭代模式.png" alt="img" style="zoom:150%;"><h3 id="_6-mediator-中介模式" tabindex="-1"><a class="header-anchor" href="#_6-mediator-中介模式"><span>6. Mediator（中介模式）</span></a></h3><p>定义：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><p><em>类图：</em></p><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/中介者模式.png" alt="img" style="zoom:150%;"><h3 id="_7-memento-备忘录模式" tabindex="-1"><a class="header-anchor" href="#_7-memento-备忘录模式"><span>7. Memento（备忘录模式）</span></a></h3><p>定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p><p><em>类图：</em></p><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/备忘录模式.png" alt="img" style="zoom:150%;"><h3 id="_8-observer-观察者模式" tabindex="-1"><a class="header-anchor" href="#_8-observer-观察者模式"><span>8. Observer（观察者模式）</span></a></h3><p>定义：定义对象间的一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖于它的对象都得到通知并被自动更新。</p><p><em>类图：</em></p><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/观察者模式.png" alt="img" style="zoom:150%;"><h3 id="_9-state-状态模式" tabindex="-1"><a class="header-anchor" href="#_9-state-状态模式"><span>9. State（状态模式）</span></a></h3><p>定义：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</p><p><em>类图：</em></p><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/状态模式.png" alt="img" style="zoom:150%;"><h3 id="_10-strategy-策略模式" tabindex="-1"><a class="header-anchor" href="#_10-strategy-策略模式"><span>10. Strategy（策略模式）</span></a></h3><p><em>定义：定义一系列的算法，把它们一个个封装起来，并且使它们可互相替换。本模式使得算法可独立于使用它的客户而变化。</em></p><p><em>类图：</em></p><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/策略模式.png" alt="img" style="zoom:150%;"><h3 id="_11-visitor-访问者模式" tabindex="-1"><a class="header-anchor" href="#_11-visitor-访问者模式"><span>11. Visitor（访问者模式）</span></a></h3><p><em>定义：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的前提下定义作用于这些元素的新操作。</em></p><p><em>类图：</em></p><img src="https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/访问者模式.png" alt="img" style="zoom:150%;">',111)],t={},l=(0,e(6262).A)(t,[["render",function(i,s){return(0,a.uX)(),(0,a.CE)("div",null,n)}]]),p=JSON.parse('{"path":"/designpattern/designPrinciple/act_one_classDiagram.html","title":"1、类图总览","lang":"zh-CN","frontmatter":{"description":"1、类图总览 一、创建型 1. Simple Factory Method（简单工厂方法） 定义：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。 类图： image-20240611195324067image-20240611195324067 案例说明： 2、Factory Method（工厂方法） 3...","head":[["meta",{"property":"og:url","content":"https://www.bugcode.online/designpattern/designPrinciple/act_one_classDiagram.html"}],["meta",{"property":"og:site_name","content":"bugcode 的架构之路"}],["meta",{"property":"og:title","content":"1、类图总览"}],["meta",{"property":"og:description","content":"1、类图总览 一、创建型 1. Simple Factory Method（简单工厂方法） 定义：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。 类图： image-20240611195324067image-20240611195324067 案例说明： 2、Factory Method（工厂方法） 3..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/202406111953482.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-21T03:15:29.000Z"}],["meta",{"property":"article:author","content":"Mr.bugcode"}],["meta",{"property":"article:modified_time","content":"2024-06-21T03:15:29.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"1、类图总览\\",\\"image\\":[\\"https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/202406111953482.png\\",\\"https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/202406201837277.png\\",\\"https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/202406201838833.png\\",\\"https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png\\",\\"https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/202406211001742.png\\",\\"https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/202406211009260.png\\",\\"https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.png\\",\\"https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/202406211011262.png\\",\\"https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/202406211014964.png\\",\\"https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/202406211016194.png\\",\\"https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/202406211018285.png\\",\\"https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/202406211016983.png\\",\\"https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/202406211017371.png\\",\\"https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/202406211019356.png\\",\\"https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/202406211012682.png\\"],\\"dateModified\\":\\"2024-06-21T03:15:29.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.bugcode\\",\\"url\\":\\"intro.md\\"}]}"]]},"headers":[{"level":2,"title":"一、创建型","slug":"一、创建型","link":"#一、创建型","children":[{"level":3,"title":"1. Simple Factory Method（简单工厂方法）","slug":"_1-simple-factory-method-简单工厂方法","link":"#_1-simple-factory-method-简单工厂方法","children":[]},{"level":3,"title":"2、Factory Method（工厂方法）","slug":"_2、factory-method-工厂方法","link":"#_2、factory-method-工厂方法","children":[]},{"level":3,"title":"3. Abstract Factory（抽象工厂）","slug":"_3-abstract-factory-抽象工厂","link":"#_3-abstract-factory-抽象工厂","children":[]},{"level":3,"title":"3. Builder（生成器模式）","slug":"_3-builder-生成器模式","link":"#_3-builder-生成器模式","children":[]},{"level":3,"title":"4. Prototype（原型模式）","slug":"_4-prototype-原型模式","link":"#_4-prototype-原型模式","children":[]},{"level":3,"title":"5. Singleton（单件模式）","slug":"_5-singleton-单件模式","link":"#_5-singleton-单件模式","children":[]}]},{"level":2,"title":"二、结构性","slug":"二、结构性","link":"#二、结构性","children":[{"level":3,"title":"1. Adapter（适配器模式（类、对象））","slug":"_1-adapter-适配器模式-类、对象","link":"#_1-adapter-适配器模式-类、对象","children":[]},{"level":3,"title":"2. Bridge（桥连模式）","slug":"_2-bridge-桥连模式","link":"#_2-bridge-桥连模式","children":[]},{"level":3,"title":"3. Composite（组合模式）","slug":"_3-composite-组合模式","link":"#_3-composite-组合模式","children":[]},{"level":3,"title":"4. Decorator（装饰模式）","slug":"_4-decorator-装饰模式","link":"#_4-decorator-装饰模式","children":[]},{"level":3,"title":"5. Facade（外观模式）","slug":"_5-facade-外观模式","link":"#_5-facade-外观模式","children":[]},{"level":3,"title":"6. Flyweight（享元模式）","slug":"_6-flyweight-享元模式","link":"#_6-flyweight-享元模式","children":[]},{"level":3,"title":"7. Proxy（代理模式）","slug":"_7-proxy-代理模式","link":"#_7-proxy-代理模式","children":[]}]},{"level":2,"title":"三、行为型","slug":"三、行为型","link":"#三、行为型","children":[{"level":3,"title":"1. Interpreter（解释器模式）","slug":"_1-interpreter-解释器模式","link":"#_1-interpreter-解释器模式","children":[]},{"level":3,"title":"2. Template Method（模板方法）","slug":"_2-template-method-模板方法","link":"#_2-template-method-模板方法","children":[]},{"level":3,"title":"3. Chain of Responsibility（职责链模式）","slug":"_3-chain-of-responsibility-职责链模式","link":"#_3-chain-of-responsibility-职责链模式","children":[]},{"level":3,"title":"4. Command（命令模式）","slug":"_4-command-命令模式","link":"#_4-command-命令模式","children":[]},{"level":3,"title":"5. Iterator（迭代模式）","slug":"_5-iterator-迭代模式","link":"#_5-iterator-迭代模式","children":[]},{"level":3,"title":"6. Mediator（中介模式）","slug":"_6-mediator-中介模式","link":"#_6-mediator-中介模式","children":[]},{"level":3,"title":"7. Memento（备忘录模式）","slug":"_7-memento-备忘录模式","link":"#_7-memento-备忘录模式","children":[]},{"level":3,"title":"8. Observer（观察者模式）","slug":"_8-observer-观察者模式","link":"#_8-observer-观察者模式","children":[]},{"level":3,"title":"9. State（状态模式）","slug":"_9-state-状态模式","link":"#_9-state-状态模式","children":[]},{"level":3,"title":"10. Strategy（策略模式）","slug":"_10-strategy-策略模式","link":"#_10-strategy-策略模式","children":[]},{"level":3,"title":"11. Visitor（访问者模式）","slug":"_11-visitor-访问者模式","link":"#_11-visitor-访问者模式","children":[]}]}],"git":{"createdTime":1718109112000,"updatedTime":1718939729000,"contributors":[{"name":"不爱打代码的程序员","email":"2284609302@qq.com","commits":2}]},"readingTime":{"minutes":6.17,"words":1850},"filePathRelative":"designpattern/designPrinciple/act_one_classDiagram.md","localizedDate":"2024年6月11日","excerpt":"\\n<h2>一、创建型</h2>\\n<h3>1. Simple Factory Method（简单工厂方法）</h3>\\n<p>定义：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。</p>\\n<p>类图：</p>\\n<figure><img src=\\"https://vscodepic.oss-cn-beijing.aliyuncs.com/blog/202406111953482.png\\" alt=\\"image-20240611195324067\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>image-20240611195324067</figcaption></figure>","autoDesc":true}')}}]);